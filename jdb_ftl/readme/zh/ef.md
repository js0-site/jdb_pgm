# Elias-Fano 索引优化：空间换时间的极致平衡

Elias-Fano (EF) 编码是一种针对单调递增序列的高效压缩算法，特别适合压缩排序后的整数数组。在本项目中，我们对标准的 Elias-Fano 实现进行了深度优化，通过引入 `u16` 跳表（Skip Table）和改进的 `predecessor` 搜索算法，在保持极低内存占用（仅增加约 1% 开销）的同时，实现了接近 O(1) 的随机访问性能。

## 1. FTL 中的应用场景

在 PGM (Piecewise Geometric Model) 动态映射系统中，为了将海量的 LBA (逻辑块地址) 映射到 PBA (物理块地址)，我们将整个映射空间切分为数千个线性的 **Segment**。

每个 Segment 都有一个起始 LBA。为了在读取时快速定位给定 LBA 属于哪个 Segment，我们需要存储并搜索这些起始 LBA 组成的单调递增序列 (`StartIdxs`)。

**为什么要用 Elias-Fano?**
1.  **极致压缩**：L2P 表及其元数据必须常驻内存。EF 编码可以将这些排序后的索引压缩到接近理论下界（每个索引仅需很少的位），显著减少 FTL 的内存占用。
2.  **快速前驱搜索**：读取路径的核心操作是 `predecessor(lba)`，用于快速定位目标所在的 Segment。
3.  **稀疏索引映射**：在新的“无洞存储”架构中，EF 编码用于直接存储所有有效数据的逻辑偏移。通过 `predecessor(lba)`，我们可以瞬间判定一个逻辑地址是否存在，并将其映射到稠密的物理数据流下标，彻底取代了原本昂贵的位图结构。

## 2. 核心架构与内存布局

我们的 Elias-Fano 实现采用了 Zero-Copy 的 `EfView` 结构，直接在内存映射的字节流上操作，无需反序列化。

内存布局如下：

```text
[Header (2 bytes)]
   - Byte 0: l (Lower bits count, 4 bits)
   - Byte 1: upper_len_bytes (Upper bits length)
[Upper Bits]
   - N + (U >> l) bits (Byte aligned)
   - 用于存储高位的一元编码 (一元编码 of Gaps)
[Lower Bits]
   - N * l bits (Byte aligned)
   - 存储低位原始值
[Skip Table]
   - ceil(N / 64) * 4 bytes
   - 存储每 64 个元素的索引加速信息
```

### 1.1 u16 跳表设计

为了解决标准 EF 编码在长序列中随机访问需要 O(N) 线性扫描的问题，我们引入了一个紧凑的跳表索引：

*   **采样间隔 (SKIP_INTERVAL)**：每 64 个元素（一个 缓存行 友好值）建立一个索引项。
*   **索引内容**：
    *   `bit_pos` (u16): 对应元素在高位流中的位偏移。
    *   `prev_h` (u16): 上一个元素的高位值，用于差量解码。
*   **空间开销**：每个索引项 4 字节。对于 N=4096 的块，需 64 个索引项，共 256 字节，仅占总数据量的极小部分（约 1%）。

## 2. 算法优化：Predecessor 搜索

`predecessor(target)` 是 FTL 中最频繁调用的操作，用于根据 LBA 查找对应的 Segment。我们实现了一种混合搜索策略，结合了二分查找和局部自适应扫描。

### 2.1 算法流程

1.  **Block 定位**：
    利用 Skip Table 中的 `prev_h`，通过二分查找快速定位到 `target` 可能存在的 Block（64 个元素范围）。这一步将搜索范围从 N 缩小到 64。

2.  **局部自适应扫描**：
    在 64 个元素的局部范围内，我们采用线性扫描。为了极致性能，我们区分了两种路径：
    *   **前向扫描（热路径）**：利用 CPU 的分支预测和缓存预取，从 Block 起始位置向前线性解码。通常只需扫描 32 次即可找到目标。
    *   **后向修正（纠错路径）**：由于哈希碰撞或边界情况，目标可能通过跳表定位到了后一个 Block。此时触发回退机制，通过 `get(idx-1)` 精确修正结果。

3.  **无状态预检查**：
    在开始扫描前，我们手动解码 Block 的第一个元素进行检查。如果第一个元素就已经大于目标值，直接回退，避免了无效的循环解码和复杂的状态同步开销。

## 3. 性能优势

*   **缓存友好**：Skip Table 小巧且连续，易于被 CPU L1/L2 缓存命中。
*   **减少分支预测失败**：局部线性扫描相比复杂的二分查找或位流跳跃，具有更稳定的指令流水线。
*   **鲁棒性**：通过双向扫描逻辑，完美覆盖了所有边界情况（如 target 小于所有值、大于所有值、恰好落在 Block 边界等）。

这一设计使得我们的 FTL 能够在大规模数据下保持微秒级的查询延迟，同时将元数据内存占用降至最低。
