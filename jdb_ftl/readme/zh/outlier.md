# 离群点识别与异常保护策略

在 PGM (Piecewise Geometric Model) 索引中，离群点（Outliers）是指那些显著偏离线性趋势的数据点。有效地识别并处理这些点，是提升压缩率与系统鲁棒性的关键。

## 1. 设计理念

### 1.1 存储成本的博弈
PGM 的核心是用 `(Base, Slope)` 描述一个分段。如果一个分段为了包含某个“刺点”而不得不增加整体的 `BitWidth`（残差位宽），或者因为该点而被迫断开分段，都会造成存储开销的激增。

我们的设计理念是：**如果将一个点作为“异常点”独立存储的成本，低于将其包含在 PGM 分段中所带来的全局增量成本，则应将其剔除。**

### 1.2 提升压缩率的逻辑
剔除离群点可以显著提高 PGM 索引的预测压缩率。为了理解这一点，我们可以看一个典型的 FTL 写入场景：

**场景：顺序写入中的局部扰动**
1. **背景**：主机正在顺序写入大量数据（如 LBA 100 → 1000），这些数据在物理存储（PBA）上通常也是连续分布的，线性趋势非常明显。
2. **扰动**：在写入过程中，突然发生了一次小的元数据更新或空间整理，导致 LBA 500 被写入了一个遥远的物理位置（如 PBA 99999），而随后的 LBA 501 又回到了正常的连续位置。
3. **无剔除策略**：PGM 在构建索引时，为了覆盖 LBA 500 这个“刺点”，必须在 500 处强制断开当前分段，并开启多个短小且斜率陡峭的分段。这会导致分段数量激增，元数据开销变大。
4. **有剔除策略**：系统识别出 LBA 500 是一个偏离整体趋势的离群点，将其从 PGM 线性建模中剔除，转而记录在旁路的“补丁表”中。这样，主 PGM 索引可以维持一个长达 900 个点的单一分段，极大地降低了存储空间。

---

## 2. 落地技术方案：Residual-Patch PGM

我们采用了一种称为 **Residual-Patch** 的混合编码方案。

### 2.1 贪心离群点提取与桥接 (Greedy Extraction with Bridging)

为了处理数据中的局部噪声，我们引入了 **Outlier Bridging（离群点桥接）** 策略。

#### 核心逻辑：从 "一刀切" 到 "向前看"
传统的 PGM 构建一旦遇到不满足误差限制的点就会立即断开分段。这在面对单点噪声时（如偶尔的元数据写入抖动）会导致长线段破碎。

我们的新策略增加了 **Lookahead (前瞻)** 机制：
1.  当遇到一个破坏线性趋势的点 `P_i` 时，算法不会立即放弃，而是尝试**跳过**该点去检查后续点 `P_{i+1}` 和 `P_{i+2}`。
2.  **趋势共识验证**：如果后续的两个点都能完美回归到当前的线性趋势中，系统就会判定 `P_i` 为**内部离群点 (Bridged Outlier)**。
3.  **桥接**：算法将 `P_i` 标记为离群点（记录在 Patch 表中），同时**维持当前线段不断开**，继续向后延伸。

#### 伪代码实现

对应源码 `src/ftl/codec/optimal.rs` 和 `pgm.rs`：

```python
# 核心算法逻辑
SKIP_THRESHOLD = 4  # 最小有效分段长度

while cursor < n:
    # 1. 寻找最长分段，支持内部跳过离群点
    #    Lookahead: 如果遇到坏点，且后续 2 个点能接上，则跳过坏点继续延伸
    (segment, skipped_indices) = find_longest_segment(start=cursor, lookahead_check=True)
    
    # 计算有效长度（排除掉中间跳过的空心点）
    effective_length = segment.length - len(skipped_indices)

    # 2. 启发式判断：分段是否过短？
    if effective_length < SKIP_THRESHOLD:
        # [Strategy: 起点剔除] 
        # 即使算上桥接，这个分段依然太短。说明起点(Anchor)本身可能就是离群的。
        # 此时放弃整个尝试，只将【起步点】作为离群点剔除，重启搜索。
        data.mark_as_outlier(cursor)
        cursor += 1
    else:
        # [Strategy: 确认分段]
        # 分段有效。提交分段信息。
        data.commit_segment(segment)
        
        # 将中间跳过的点注册为“内部离群点”
        for idx in skipped_indices:
            data.mark_as_outlier(cursor + idx)
            
        cursor += segment.length
```


### 2.2 残差补丁编码
对于识别出的离群点，我们不存储原始 PBA，而是存储其与 PGM 模型预测值之间的**残差**。
- **ZigZag 编码**: 处理正负偏差，将其映射到无符号空间。
- **动态位宽打包**: 统计整组离群点的最大残差，确定一个最优位宽 `OutlierBW` 进行批量打包。

### 2.3 异常保护布局
为了确保极端情况下的安全性，我们设计了 **原始回退** 机制：
- **计算**: 编码器在产出结果前会计算总字节数（Header + Index + PGM + Patches）。
- **回退**: 如果总长度超过原始未压缩大小（32KB），则自动回退到 `Mode 0`（原始存储），并修改 `GroupHeader` 标志。这保证了即使面对完全不可压缩的随机数据，系统也不会崩溃或空间膨胀。

---

## 3. 性能表现

在实际 Trace 测试中，该策略带来了显著改进：
- **压缩率提升**: 离群点剔除使得平均 PGM 段长提升了 55%，全局空间节省从 10% 跃升至 **35%**。
- **读取性能**: 利用 Elias-Fano 索引，点查询可以快速判断是否命中补丁表，避免了复杂的 PGM 计算。

---
> 更多编解码细节请参考 [Codec 详细文档](codec.md)。
