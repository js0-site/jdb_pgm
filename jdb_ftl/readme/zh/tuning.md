# 配置系统与自动化调优：寻找性能的最优解

JDB-FTL 的设计理念是“场景适配”。不同的工作负载（如顺序读写、大规模随机写、由于 GC 导致的离群点分布）需要不同的超参数来换取最优的内存占用与访问速度。


## 1. 零开销静态配置系统

JDB-FTL 放弃了运行时字典查找，采用了基于 **Rust Trait** 的零开销静态配置方案：

### 1.1 `Conf` 特性
*   **物理实现**：通过 `build.rs` 在编译期根据配置文件动态生成 `Conf` trait 实现及其对应的静态策略代码。
*   **优势**：由于配置在编译期已确定，编译器可以对相关的掩码运算、位移常数进行内联优化，彻底消除了访问全局变量或解析 JSON 带来的运行时开销。

### 1.2 关键配置项
*   **`GROUP_SIZE`**：数据组的大小。较大的组可以提升分段的连续性从而增加压缩率，但会增加组内搜索的延迟。
*   **`PGM_EPSILON`**：PGM 拟合的允许误差。这是压缩率与拟合精度的核心权衡点。
*   **`WRITE_BUFFER_CAPACITY`**：L0 缓冲区的大小，决定了后台刷新的触发频率。


## 2. 自动化调优 : tune.py

面对海量的参数组合，人工调试往往难以覆盖最优解。我们提供了一套闭环的超参数调优工具：

### 2.1 基于遗传算法的超参数搜索
*   **工具路径**：`tune.py`（调用 `examples/score.rs`）
*   **工作逻辑**：利用 差分进化超频带 算法，针对给定的 Trace 轨迹文件，在预设的参数空间内进行演化搜索。
*   **优化目标**：`Score = Throughput`（最大化吞吐量），配合以下硬性约束条件：
    - **压缩率 < 30%**：超过则分数惩罚至 1%
    - **吞吐量 ≥ 95% 基准**：低于则分数惩罚至 1%
    - **P99 延迟 ≤ 110% 基准**：超过则分数惩罚至 1%

### 2.2 调优工作流
1.  **数据采集**：从生成环境中捕获真实的 LBA 读写 Trace。
2.  **演化训练**：运行 `tune.py`，工具会自动并发运行数个 FTL 实例并计算得分。
3.  **参数落地**：根据工具输出的最优参数，生成 `Conf` trait 实现并重新编译项目。


## 3. 性能演进成本模型

为了帮助工程师做出科学决策，我们总结了以下核心参数及其调优策略：

### 关键编译时配置参数

| 参数名                  | 默认值    | 描述                                  |
| :---------------------- | :-------- | :------------------------------------ |
| `GROUP_SIZE`            | 4096      | 每个数据组管理的 LBA 条目数           |
| `PGM_EPSILON`           | 512       | PGM 模型允许的误差阈值                |
| `WRITE_BUFFER_CAPACITY` | 4,194,304 | L0 缓冲区大小 (4MB)，控制后台刷新频率 |

> [!NOTE]
> 这些参数可以通过环境变量 (`FTL_GROUP_SIZE`, `FTL_PGM_EPSILON`, `FTL_BUFFER_CAPACITY`) 或使用 `tune.py` 自动化搜索工具进行调整。


## 4. 结论

没有一个模型能通吃所有场景，但通过以 **PGM INDEX + 自适应位宽残差补偿 = 无损压缩** 为核心的“静态配置”+“自动调优”双轮驱动，JDB-FTL 能够让映射表在不同的存储器形态（如 NVMe SSD、持久内存等）上都能够通过简单的参数演进，达成工业级的性能表现。